name: build-bonding-full-selfcontained

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch: {}

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate project (code + requirements)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path client | Out-Null
          New-Item -ItemType Directory -Force -Path server | Out-Null
          New-Item -ItemType Directory -Force -Path engine | Out-Null
          New-Item -ItemType File -Force -Path engine/__init__.py | Out-Null

          @"
          PyQt5>=5.15,<6
          psutil>=5.9
          "@ | Set-Content -Encoding UTF8 requirements.txt

          # ---------- engine/bonding_common.py (утилиты, если понадобится дальше) ----------
          @"
          import sys, time, threading, socket, subprocess, platform, os, shutil
          def log(*a):
              ts = time.strftime("%Y-%m-%d %H:%M:%S")
              print(f"[{ts}] " + " ".join(str(x) for x in a), flush=True)
          def bundled_tool(name):
              if getattr(sys, "frozen", False):
                  base = getattr(sys, "_MEIPASS", os.path.dirname(sys.argv[0]))
                  p = os.path.join(base, name)
                  if os.path.exists(p): return p
                  alt = os.path.join(os.path.dirname(sys.argv[0]), name)
                  if os.path.exists(alt): return alt
              else:
                  here = os.path.dirname(__file__)
                  p3 = os.path.join(here, "..", name)
                  if os.path.exists(p3): return p3
              return shutil.which(name)
          "@ | Set-Content -Encoding UTF8 engine/bonding_common.py

          # ---------- engine/bonding_engine_client.py (взвешенный RR + чтение weights.json) ----------
          @"
          import sys, json, socket, time, argparse

          def log(*a):
              ts = time.strftime("%Y-%m-%d %H:%M:%S")
              sys.stdout.write(f"[{ts}] " + " ".join(str(x) for x in a) + "\n"); sys.stdout.flush()

          class WeightedRR:
              def __init__(self, n, weights=None):
                  self.n = n
                  self.set_weights(weights or [1]*n)
              def set_weights(self, w):
                  self.weights = [max(0, int(x)) for x in (w or [1]*self.n)]
                  self._ring = []
                  for i,wt in enumerate(self.weights):
                      self._ring += [i]*wt
                  if not self._ring:
                      self._ring = [i for i,w in enumerate(self.weights) if w>0] or [0]
                  self._pos = 0
              def next(self):
                  if not self._ring: return None
                  i = self._ring[self._pos]; self._pos = (self._pos + 1) % len(self._ring); return i

          def load_weights(path, n):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      arr = json.load(f)
                  if isinstance(arr, list) and len(arr)>=n:
                      return [int(x) for x in arr[:n]]
              except Exception:
                  pass
              return None

          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              ap.add_argument('--weights', default=None)
              args=ap.parse_args()

              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              server_ip = cfg.get('server_ip','127.0.0.1')
              ports     = cfg.get('server_ports',[12001,12002,12003,12004])
              chunk     = int(cfg.get('ts_chunk',1316))
              enable    = cfg.get('enable_paths', [True]*len(ports))
              n = len(ports)

              socks=[]
              for i,p in enumerate(ports):
                  if i<len(enable) and not enable[i]:
                      socks.append(None); continue
                  s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                  s.setblocking(False)
                  socks.append((s,(server_ip,int(p))))

              wrr = WeightedRR(n, [1]*n)
              log('[engine-client] ->', server_ip, ports, 'chunk', chunk)
              last_w_check = 0
              buf=b''

              try:
                  while True:
                      data = sys.stdin.buffer.read1(64*1024)
                      if data: buf += data
                      else: time.sleep(0.005)

                      now = time.time()
                      if args.weights and (now - last_w_check) >= 0.5:
                          ww = load_weights(args.weights, n)
                          if ww: wrr.set_weights(ww)
                          last_w_check = now

                      while len(buf) >= chunk:
                          pkt, buf = buf[:chunk], buf[chunk:]
                          attempt = 0; sent = False
                          while attempt < n:
                              idx = wrr.next()
                              if idx is None: break
                              if idx < n and socks[idx] is not None and wrr.weights[idx] > 0:
                                  s, addr = socks[idx]
                                  try:
                                      s.sendto(pkt, addr); sent = True; break
                                  except Exception: pass
                              attempt += 1
                          if not sent: time.sleep(0.002)
              except KeyboardInterrupt:
                  pass

          if __name__=='__main__': main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_client.py

          # ---------- engine/bonding_engine_server.py (эха для QoS + склейка) ----------
          @"
          import sys, json, socket, time, argparse, select

          def log(*a):
              ts = time.strftime("%Y-%m-%d %H:%M:%S")
              sys.stdout.write(f"[{ts}] " + " ".join(str(x) for x in a) + "\n"); sys.stdout.flush()

          QOS_MAGIC = b'QOS1'

          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              args=ap.parse_args()

              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              ports=cfg.get('listen_ports',[12001,12002,12003,12004])
              out_ip,out_port = cfg.get('output_udp',['127.0.0.1',10080])

              socks=[]
              for p in ports:
                  s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
                  s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
                  s.bind(('0.0.0.0',int(p)))
                  s.setblocking(False)
                  socks.append(s)

              out = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
              out_addr=(out_ip,int(out_port))

              total=0; last=time.time()
              log('[engine-server] listen',ports,'->',out_addr)

              try:
                  while True:
                      r,_,_ = select.select(socks,[],[],0.05)
                      for s in r:
                          try:
                              data,addr = s.recvfrom(65536)
                              if data.startswith(QOS_MAGIC) and len(data) >= 9:
                                  s.sendto(data, addr); continue
                              out.sendto(data,out_addr); total+=1
                          except Exception:
                              pass
                      now=time.time()
                      if now-last>=1.0:
                          log(f'[engine-server] rx_chunks/s={total}')
                          total=0; last=now
              except KeyboardInterrupt:
                  pass

          if __name__=='__main__': main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_server.py

          # ---------- client/client_gui.py (preview 30%, QoS-пробник, 6 путей) ----------
          @"
          import sys, os, json, subprocess, shutil, time, re, socket, struct
          from PyQt5.QtWidgets import (
              QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QListWidget, QListWidgetItem,
              QFileDialog, QFrame, QStyleFactory, QCheckBox, QMessageBox
          )
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal = QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45))
                  pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30))
                  pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52))
                  pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255))
                  pal.setColor(QPalette.HighlightedText, Qt.white)
              else:
                  pal = app.palette()
              app.setPalette(pal)
          def bundled_tool(name):
              if getattr(sys, 'frozen', False):
                  base = getattr(sys, '_MEIPASS', os.path.dirname(sys.argv[0]))
                  p = os.path.join(base, name)
                  if os.path.exists(p): return p
                  alt = os.path.join(os.path.dirname(sys.argv[0]), name)
                  if os.path.exists(alt): return alt
              else:
                  here = os.path.dirname(__file__)
                  p3 = os.path.join(here, '..', name)
                  if os.path.exists(p3): return p3
              return shutil.which(name)

          QOS_MAGIC = b'QOS1'

          class QoSProbe:
              def __init__(self, server_ip, ports, enabled_mask):
                  self.server_ip = server_ip; self.ports = list(ports); self.enabled = list(enabled_mask)
                  self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); self.sock.setblocking(False)
                  self.seq = 0
                  self.outstanding = [{} for _ in self.ports]
                  self.rtt = [None]*len(self.ports)
                  self.sent = [0]*len(self.ports); self.recv = [0]*len(self.ports); self.last_rx = [0]*len(self.ports)
                  self.weights = [1]*len(self.ports)
              def set_enabled(self, enabled_mask): self.enabled = list(enabled_mask)
              def tick_send(self):
                  now = time.time()
                  for i,port in enumerate(self.ports):
                      if i < len(self.enabled) and not self.enabled[i]: continue
                      self.seq = (self.seq + 1) & 0xFFFFFFFF
                      payload = QOS_MAGIC + bytes([i & 0xFF]) + struct.pack('!I', self.seq)
                      try:
                          self.sock.sendto(payload, (self.server_ip, int(port)))
                          self.outstanding[i][self.seq] = now; self.sent[i] += 1
                      except Exception: pass
              def tick_recv(self):
                  now = time.time()
                  while True:
                      try: data, addr = self.sock.recvfrom(2048)
                      except BlockingIOError: break
                      except Exception: break
                      if not data.startswith(QOS_MAGIC) or len(data) < 9: continue
                      path = data[4]; seq = struct.unpack('!I', data[5:9])[0]
                      if path >= len(self.ports): continue
                      t0 = self.outstanding[path].pop(seq, None)
                      if t0 is None: continue
                      rtt_ms = (now - t0)*1000.0
                      prev = self.rtt[path]; self.rtt[path] = (0.7*prev + 0.3*rtt_ms) if prev is not None else rtt_ms
                      self.recv[path] += 1; self.last_rx[path] = now
              def compute_weights(self):
                  w=[]
                  for i in range(len(self.ports)):
                      if i < len(self.enabled) and not self.enabled[i]: w.append(0); continue
                      if (time.time() - self.last_rx[i]) > 5 and self.recv[i]==0: w.append(0); continue
                      s = max(1, self.sent[i]); loss = max(0.0, min(1.0, 1.0 - (self.recv[i]/s)))
                      rtt = self.rtt[i] if self.rtt[i] is not None else 300.0
                      score = (1000.0/(1.0 + rtt)) * (1.0 - 0.7*loss)
                      if score <= 1: wt = 0
                      elif score >= 4: wt = 5
                      else: wt = max(1, min(5, int(round(score))))
                      w.append(wt)
                  self.weights = w; return w
              def reset_window(self):
                  self.sent = [0]*len(self.ports); self.recv = [0]*len(self.ports)
                  for i in range(len(self.outstanding)): self.outstanding[i].clear()

          class ClientGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Client'); self.resize(1220,880)
                  self.ff=None; self.eng=None; self.preview=None
                  self.current_source = None; self.last_w = None; self.last_h = None
                  self.qos = None; self.weights_path = os.path.abspath('weights.json')

                  root=QVBoxLayout(self)
                  top=QHBoxLayout(); ttl=QLabel('Bonding Client'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())
                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  tab_src=QWidget(); sL=QVBoxLayout(tab_src)
                  g_src=QGroupBox('Video Source'); gL=QHBoxLayout(g_src)
                  self.src_mode=QComboBox(); self.src_mode.addItems(['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener'])
                  gL.addWidget(QLabel('Type:')); gL.addWidget(self.src_mode)
                  self.btn_pick=QPushButton('Pick file'); self.btn_pick.clicked.connect(self.pick_file); gL.addWidget(self.btn_pick)
                  self.btn_apply=QPushButton('Apply Source'); self.btn_apply.clicked.connect(self.apply_source); gL.addWidget(self.btn_apply)
                  sL.addWidget(g_src)
                  g_pl=QGroupBox('Playlist'); gpl=QVBoxLayout(g_pl)
                  self.list=QListWidget(); gpl.addWidget(self.list)
                  hb=QHBoxLayout(); b1=QPushButton('Add'); b2=QPushButton('Remove')
                  b1.clicked.connect(self.add_files); b2.clicked.connect(self.remove_files); hb.addWidget(b1); hb.addWidget(b2); gpl.addLayout(hb)
                  sL.addWidget(g_pl)
                  g_prev=QGroupBox('Preview'); gpv=QHBoxLayout(g_prev)
                  self.btn_prev_play = QPushButton('Play Preview'); self.btn_prev_stop = QPushButton('Stop Preview')
                  self.btn_prev_play.clicked.connect(self.preview_play); self.btn_prev_stop.clicked.connect(self.preview_stop)
                  gpv.addWidget(self.btn_prev_play); gpv.addWidget(self.btn_prev_stop); sL.addWidget(g_prev)
                  self.src_info = QLabel('Source: —  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —')
                  self.src_info.setStyleSheet('padding:6px; border:1px solid #3a3f45; border-radius:6px;'); sL.addWidget(self.src_info)
                  tabs.addTab(tab_src,'Source')

                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_srv=QGroupBox('Server & Paths'); gs=QHBoxLayout(g_srv)
                  self.server_ip=QLineEdit('127.0.0.1'); self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(6,6); self.paths.setValue(6); self.ts_chunk=QSpinBox(); self.ts_chunk.setRange(188,4096); self.ts_chunk.setValue(1316)
                  for w in (QLabel('Server IP:'),self.server_ip,QLabel('Base port:'),self.base_port,QLabel('Paths (fixed):'),self.paths,QLabel('TS chunk:'),self.ts_chunk): gs.addWidget(w)
                  nL.addWidget(g_srv)
                  g_paths=QGroupBox('Paths enable'); gp=QHBoxLayout(g_paths)
                  labels = ['Mod1','Mod2','Mod3','Mod4','Ethernet','Wi-Fi']; self.path_enable=[]
                  for i,name in enumerate(labels):
                      cb = QCheckBox(name); cb.setChecked(True if i<4 else False); gp.addWidget(cb); self.path_enable.append(cb)
                  self.eth_cb = self.path_enable[4]; self.wifi_cb = self.path_enable[5]
                  self.eth_cb.stateChanged.connect(self._toggle_eth); self.wifi_cb.stateChanged.connect(self._toggle_wifi)
                  nL.addWidget(g_paths)
                  self.lbl_weights = QLabel('Path weights: —'); nL.addWidget(self.lbl_weights)
                  tabs.addTab(tab_net,'Network')

                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_enc=QGroupBox('Encoding'); ge=QHBoxLayout(g_enc)
                  self.vcodec=QComboBox(); self.vcodec.addItems(['libx264','h264_nvenc','libx265'])
                  self.profile=QComboBox(); self.profile.addItems(['baseline','main','high'])
                  self.vbit=QSpinBox(); self.vbit.setRange(500,20000); self.vbit.setValue(6000)
                  self.preset=QComboBox(); self.preset.addItems(['ultrafast','veryfast','faster','fast','medium'])
                  for w in (QLabel('Codec:'),self.vcodec,QLabel('Profile:'),self.profile,QLabel('Bitrate kbps:'),self.vbit,QLabel('Preset:'),self.preset): ge.addWidget(w)
                  oL.addWidget(g_enc)
                  g_proto=QGroupBox('Output protocol (for server publish)'); gp2=QHBoxLayout(g_proto)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP']); self.srt_url=QLineEdit('srt://127.0.0.1:9999?mode=caller')
                  for w in (QLabel('Protocol:'),self.proto,QLabel('URL:'),self.srt_url): gp2.addWidget(w)
                  oL.addWidget(g_proto); tabs.addTab(tab_out,'Streaming')

                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;'); lL.addWidget(self.logs,1)
                  tabs.addTab(tab_log,'Logs')

                  bb=QHBoxLayout(); bb.addStretch(1); self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop'); bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)

                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(120)
                  self.qos_send_timer = QTimer(self); self.qos_send_timer.timeout.connect(self._qos_send_tick); self.qos_send_timer.start(1000)
                  self.qos_rcv_timer = QTimer(self); self.qos_rcv_timer.timeout.connect(self._qos_recv_tick); self.qos_rcv_timer.start(500)
                  apply_theme(self.app,'Light'); self.apply_source(initial=True)

              def log(self,msg):
                  ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
                  self.logs.appendPlainText(f'[{ts}] {msg}')
              def _ffmpeg(self):  return bundled_tool('ffmpeg.exe')
              def _ffprobe(self): return bundled_tool('ffprobe.exe')
              def _ffplay(self):  return bundled_tool('ffplay.exe')

              def pick_file(self):
                  p,_=QFileDialog.getOpenFileName(self,'Pick video','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  if p: self.list.addItem(QListWidgetItem(p))
              def add_files(self):
                  files,_=QFileDialog.getOpenFileNames(self,'Add to playlist','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  for f in files: self.list.addItem(QListWidgetItem(f))
              def remove_files(self):
                  for it in self.list.selectedItems(): self.list.takeItem(self.list.row(it))

              def apply_source(self, initial=False):
                  new_idx = self.src_mode.currentIndex(); new_desc = self._source_desc(new_idx)
                  if not initial:
                      reply = QMessageBox.question(self, 'Apply Source', f'Switch source to: {new_desc}?', QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                      if reply != QMessageBox.Yes: return
                  self.current_source = new_idx; self.log(f'Applied source: {new_desc}'); self.update_source_info()
              def _source_desc(self, idx):
                  names = ['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener']
                  return names[idx] if 0 <= idx < len(names) else 'Unknown'
              def _fps_str(self, fr):
                  try:
                      num, den = fr.split('/'); den = float(den) if float(den)!=0 else 1.0
                      return f'{float(num)/den:.2f}'
                  except Exception: return fr
              def _probe_file(self, path):
                  fmt='—'; w=h=None; fps='—'; a='—'; ffprobe = self._ffprobe()
                  if not ffprobe: return fmt,w,h,fps,a
                  out = subprocess.check_output([ffprobe,'-v','error','-select_streams','v:0','-show_entries','stream=width,height,avg_frame_rate','-of','default=noprint_wrappers=1:nokey=1',path], stderr=subprocess.STDOUT)
                  parts = out.decode(errors='ignore').strip().splitlines()
                  if len(parts) >= 3:
                      w = int(parts[0]); h = int(parts[1]); fr = parts[2]; fps = fr if '/' not in fr else self._fps_str(fr)
                  out2 = subprocess.check_output([ffprobe,'-v','error','-select_streams','a:0','-show_entries','stream=sample_rate,channels','-of','default=noprint_wrappers=1:nokey=1',path], stderr=subprocess.STDOUT)
                  aparts = out2.decode(errors='ignore').strip().splitlines()
                  if len(aparts)>=2: a = f'{aparts[1]}ch @ {aparts[0]}Hz'
                  fmt = os.path.splitext(path)[1].lstrip('.').upper(); return fmt,w,h,fps,a
              def _probe_dshow_mode(self, device_name):
                  ff = self._ffmpeg()
                  if not ff: return None, None, 'n/a'
                  try:
                      p = subprocess.run([ff,'-hide_banner','-f','dshow','-list_options','true','-i',f'video={device_name}'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding='utf-8', errors='ignore', timeout=6)
                      tx = p.stdout
                      m = re.search(r"s=(\d+)x(\d+).*?fps=(\d+(?:\.\d+)?)", tx)
                      if m: return int(m.group(1)), int(m.group(2)), m.group(3)
                      m2 = re.search(r"s=(\d+)x(\d+)", tx)
                      if m2: return int(m2.group(1)), int(m2.group(2)), 'n/a'
                  except Exception as e:
                      self.log(f'dshow probe error: {e}')
                  return None, None, 'n/a'
              def update_source_info(self):
                  fmt='—'; v='—'; fps='—'; a='—'; self.last_w=None; self.last_h=None
                  try:
                      if self.current_source == 0:
                          if self.list.count()==0: self.src_info.setText('Source: File/Playlist  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —'); return
                          path=self.list.item(0).text(); fmt,w,h,fps,a = self._probe_file(path)
                          if w and h: v=f'{w}x{h}'; self.last_w=w; self.last_h=h
                      elif self.current_source == 1:
                          dev='Integrated Camera'; w,h,fps = self._probe_dshow_mode(dev); fmt='DShow'; a='n/a'
                          if w and h: v=f'{w}x{h}'; self.last_w=w; self.last_h=h
                          else: v='n/a'
                      elif self.current_source == 2:
                          dev='vMix Video'; w,h,fps = self._probe_dshow_mode(dev); fmt='DShow(vMix)'; a='n/a'
                          if w and h: v=f'{w}x{h}'; self.last_w=w; self.last_h=h
                          else: v='n/a'
                      elif self.current_source == 3:
                          fmt='NDI'; v='dynamic'; fps='dynamic'; a='dynamic'
                      else:
                          fmt='SRT listener'; v='dynamic'; fps='dynamic'; a='dynamic'
                  except Exception as e:
                      self.log(f'probe error: {e}')
                  self.src_info.setText(f'Source: {self._source_desc(self.current_source)}  |  Format: {fmt}  |  Video: {v}  |  FPS: {fps}  |  Audio: {a}')
              def preview_play(self):
                  self.preview_stop(); ply = self._ffplay()
                  if not ply: QMessageBox.warning(self,'Preview','ffplay.exe not found in bundle.'); return
                  mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
                  cmd=[ply,'-hide_banner','-loglevel','error']
                  sw,sh = (max(1,int(self.last_w*0.3)), max(1,int(self.last_h*0.3))) if (self.last_w and self.last_h) else (640,360)
                  cmd+=['-x',str(sw),'-y',str(sh)]
                  if mode==0:
                      if self.list.count()==0: self.log('Add files to preview.'); return
                      cmd+=[self.list.item(0).text()]
                  elif mode==1: cmd+=['-f','dshow','-i','video=Integrated Camera']
                  elif mode==2: cmd+=['-f','dshow','-i','video=vMix Video']
                  elif mode==3:
                      self.log('NDI preview: ensure NDI Runtime installed.'); cmd+=['-f','libndi_newtek','-i','NDI Source Name']
                  else: cmd+=['srt://0.0.0.0:9999?mode=listener']
                  try:
                      self.preview = subprocess.Popen(cmd); self.log(f'Preview started ({sw}x{sh})')
                  except Exception as e: self.log(f'Preview error: {e}')
              def preview_stop(self):
                  if self.preview and self.preview.poll() is None:
                      try: self.preview.terminate()
                      except: pass
                  self.preview=None

              def _write_client_cfg(self, path):
                  base=int(self.base_port.value()); ports=[base+i for i in range(6)]
                  enables=[cb.isChecked() for cb in self.path_enable]
                  cfg={'server_ip': self.server_ip.text().strip(),'server_ports': ports,'ts_chunk': int(self.ts_chunk.value()),'enable_paths': enables}
                  open(path,'w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2)); return cfg

              def start_all(self):
                  self.stop_all()
                  ff=self._ffmpeg()
                  if not ff: QMessageBox.warning(self,'FFmpeg','ffmpeg.exe not found in bundle.'); return
                  mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
                  cmd=[ff,'-hide_banner','-re']
                  if mode==0:
                      items=[self.list.item(i).text() for i in range(self.list.count())]
                      if not items: self.log('Add files to playlist.'); return
                      open('playlist.txt','w',encoding='utf-8').write("`n".join([f"file '{p}'" for p in items]))
                      cmd+=['-f','concat','-safe','0','-i','playlist.txt']
                  elif mode==1: cmd+=['-f','dshow','-i','video=Integrated Camera']
                  elif mode==2: cmd+=['-f','dshow','-i','video=vMix Video']
                  elif mode==3:
                      self.log('NDI selected. Ensure NDI Runtime (NDI Tools) is installed.')
                      cmd+=['-f','libndi_newtek','-i','NDI Source Name']
                  else: cmd+=['-i','srt://0.0.0.0:9999?mode=listener']
                  cmd+=['-vcodec',self.vcodec.currentText(),'-profile:v',self.profile.currentText(),'-b:v',f"{self.vbit.value()}k",
                        '-preset',self.preset.currentText(),'-acodec','aac','-b:a','128k','-f','mpegts','-']
                  try:
                      self.ff = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('ffmpeg started (bundled)')
                  except Exception as e: self.log(f'ffmpeg error: {e}'); return

                  cfg_path='bonding_client.json'; cfg = self._write_client_cfg(cfg_path)
                  ports = cfg['server_ports']; enables = cfg['enable_paths']
                  self.qos = QoSProbe(self.server_ip.text().strip(), ports, enables)
                  init_weights = [1 if en else 0 for en in enables]; self._write_weights(init_weights)

                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineClient.exe')
                  if not os.path.exists(engine): self.log('BondingEngineClient.exe not found'); return
                  try:
                      self.eng = subprocess.Popen([engine,'--config',cfg_path,'--weights',self.weights_path], stdin=self.ff.stdout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                      self.log('engine client started')
                  except Exception as e: self.log(f'engine error: {e}')
              def stop_all(self):
                  self.preview_stop()
                  for p in [self.eng,self.ff]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.eng=None; self.ff=None; self.log('Stopped'); self.qos=None
              def _pump_logs(self):
                  for p in [self.ff,self.eng]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass
              def _write_weights(self, weights):
                  try:
                      with open(self.weights_path, 'w', encoding='utf-8') as f: json.dump(weights, f, ensure_ascii=False)
                      self.lbl_weights.setText(f'Path weights: {weights}')
                  except Exception as e: self.log(f'write weights error: {e}')
              def _qos_send_tick(self):
                  if not self.qos: return
                  en=[cb.isChecked() for cb in self.path_enable]; self.qos.set_enabled(en); self.qos.tick_send()
              def _qos_recv_tick(self):
                  if not self.qos: return
                  self.qos.tick_recv(); w=self.qos.compute_weights(); self._write_weights(w)
                  if int(time.time()) % 10 == 0: self.qos.reset_window()

              def _toggle_eth(self, state):
                  name = self._find_iface('ethernet')
                  if not name: self.log('Ethernet interface not found'); return
                  ok = self._set_iface(name, state==Qt.Checked); self.log(f"Ethernet {'ENABLED' if ok and state==Qt.Checked else 'DISABLED' if ok else 'toggle FAILED'} ({name})")
              def _toggle_wifi(self, state):
                  name = self._find_iface('wifi')
                  if not name: self.log('Wi-Fi interface not found'); return
                  ok = self._set_iface(name, state==Qt.Checked); self.log(f"Wi-Fi {'ENABLED' if ok and state==Qt.Checked else 'DISABLED' if ok else 'toggle FAILED'} ({name})")
              def _find_iface(self, kind='ethernet'):
                  try:
                      out = subprocess.check_output(['netsh','interface','show','interface'], stderr=subprocess.STDOUT, encoding='utf-8', errors='ignore')
                      names=[l.strip().split()[-1] for l in out.splitlines() if l.strip() and not l.strip().startswith('Admin')]
                      pref = (['Ethernet','Ethernet 2','Локальная сеть'] if kind=='ethernet' else ['Wi-Fi','Беспроводная сеть'])
                      for p in pref:
                          for n in names:
                              if n.lower()==p.lower(): return n
                  except Exception: pass
                  return None
              def _set_iface(self, name, en=True):
                  try:
                      subprocess.check_call(['netsh','interface','set','interface', f'name={name}', f'admin={"ENABLED" if en else "DISABLED"}'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                      return True
                  except Exception: return False

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ClientGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 client/client_gui.py

          # ---------- server/server_gui.py (без импортов из engine) ----------
          @"
          import sys, os, json, subprocess, shutil, time
          from PyQt5.QtWidgets import (QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QStyleFactory, QFrame, QMessageBox)
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal=QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45)); pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30)); pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52)); pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255)); pal.setColor(QPalette.HighlightedText, Qt.white)
              else: pal = app.palette()
              app.setPalette(pal)
          def bundled_tool(name):
              if getattr(sys, 'frozen', False):
                  base = getattr(sys, '_MEIPASS', os.path.dirname(sys.argv[0]))
                  p = os.path.join(base, name)
                  if os.path.exists(p): return p
                  alt = os.path.join(os.path.dirname(sys.argv[0]), name)
                  if os.path.exists(alt): return alt
              else:
                  here = os.path.dirname(__file__)
                  p3 = os.path.join(here, '..', name)
                  if os.path.exists(p3): return p3
              return shutil.which(name)

          class ServerGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Server'); self.resize(1100,780)
                  self.eng=None; self.pub=None
                  root=QVBoxLayout(self)
                  top=QHBoxLayout(); ttl=QLabel('Bonding Server'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())
                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_listen=QGroupBox('Listen ports'); gL=QHBoxLayout(g_listen)
                  self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(6,6); self.paths.setValue(6)
                  self.group_udp_port=QSpinBox(); self.group_udp_port.setRange(1000,65535); self.group_udp_port.setValue(10080)
                  for w in (QLabel('Base port:'),self.base_port,QLabel('Paths (fixed):'),self.paths,QLabel('Merge to UDP port:'),self.group_udp_port): gL.addWidget(w)
                  nL.addWidget(g_listen); tabs.addTab(tab_net,'Network')

                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_pub=QGroupBox('Publish'); gp=QHBoxLayout(g_pub)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
                  self.srt_host=QLineEdit('0.0.0.0'); self.srt_port=QSpinBox(); self.srt_port.setRange(1000,65535); self.srt_port.setValue(9999)
                  self.srt_mode=QComboBox(); self.srt_mode.addItems(['listener','caller'])
                  self.rtmp_url=QLineEdit('rtmp://live.twitch.tv/app/STREAM_KEY')
                  for w in (QLabel('Protocol:'),self.proto,QLabel('SRT host:'),self.srt_host,QLabel('port:'),self.srt_port,QLabel('mode:'),self.srt_mode,QLabel('RTMP URL:'),self.rtmp_url): gp.addWidget(w)
                  oL.addWidget(g_pub); tabs.addTab(tab_out,'Streaming')

                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;'); lL.addWidget(self.logs,1)
                  tabs.addTab(tab_log,'Logs')

                  bb=QHBoxLayout(); bb.addStretch(1); self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop'); bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)
                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
                  apply_theme(self.app,'Light')

              def _ffmpeg(self): return bundled_tool('ffmpeg.exe')
              def log(self,msg):
                  ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss'); self.logs.appendPlainText(f'[{ts}] {msg}')

              def start_all(self):
                  self.stop_all()
                  ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
                  cfg={'listen_ports': ports, 'output_udp': ['127.0.0.1', int(self.group_udp_port.value())]}
                  open('bonding_server.json','w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2))
                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineServer.exe')
                  if not os.path.exists(engine): self.log('BondingEngineServer.exe not found'); return
                  try:
                      self.eng=subprocess.Popen([engine,'--config','bonding_server.json'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('engine server started')
                  except Exception as e: self.log(f'engine error: {e}'); return

                  ff=self._ffmpeg()
                  if not ff: QMessageBox.warning(self,'FFmpeg','ffmpeg.exe not found in bundle.'); return
                  src=f'udp://127.0.0.1:{int(self.group_udp_port.value())}?fifo_size=1000000&overrun_nonfatal=1'
                  cmd=[ff,'-hide_banner','-fflags','nobuffer','-i',src,'-c:a','aac','-b:a','128k']
                  if self.proto.currentText()=='SRT':
                      out=f'srt://{self.srt_host.text().strip()}:{int(self.srt_port.value())}?mode={self.srt_mode.currentText()}'
                      cmd+=['-c:v','copy','-f','mpegts',out]
                  else:
                      cmd+=['-c:v','libx264','-preset','veryfast','-b:v','6000k','-f','flv',self.rtmp_url.text().strip()]
                  try:
                      self.pub=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('publish started (bundled ffmpeg)')
                  except Exception as e: self.log(f'publish error: {e}')

              def stop_all(self):
                  for p in [self.pub,self.eng]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.pub=None; self.eng=None; self.log('Stopped')

              def _pump_logs(self):
                  for p in [self.eng,self.pub]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ServerGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 server/server_gui.py

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Download FFmpeg (win64 GPL) and extract binaries
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest"
          $asset = $rel.assets | Where-Object { $_.name -like "ffmpeg-master-latest-win64-gpl.zip" } | Select-Object -First 1
          if(-not $asset){ throw "FFmpeg asset not found in latest release." }
          $zip = Join-Path $env:RUNNER_TEMP $asset.name
          Invoke-WebRequest -Uri $asset.browser_download_url -OutFile $zip
          Expand-Archive -Path $zip -DestinationPath "$env:RUNNER_TEMP\ffm" -Force
          $exe = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffmpeg.exe | Select-Object -First 1
          $prb = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffprobe.exe | Select-Object -First 1
          $ply = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffplay.exe | Select-Object -First 1
          if(-not $exe -or -not $prb -or -not $ply){ throw "ffmpeg/ffprobe/ffplay not found in archive." }
          Copy-Item $exe.FullName -Destination "$PWD\ffmpeg.exe"
          Copy-Item $prb.FullName -Destination "$PWD\ffprobe.exe"
          Copy-Item $ply.FullName -Destination "$PWD\ffplay.exe"
          Write-Host "FFmpeg/FFprobe/FFplay copied to repo root."

      - name: Build engines (console)
        run: |
          pyinstaller -F engine/bonding_engine_client.py -n BondingEngineClient
          pyinstaller -F engine/bonding_engine_server.py -n BondingEngineServer

      - name: Build GUIs (windowed) with bundled FFmpeg
        run: |
          pyinstaller -w -F client/client_gui.py -n BondingClient --add-binary "ffmpeg.exe;." --add-binary "ffprobe.exe;." --add-binary "ffplay.exe;."
          pyinstaller -w -F server/server_gui.py -n BondingServer --add-binary "ffmpeg.exe;." --add-binary "ffprobe.exe;." --add-binary "ffplay.exe;."

      - name: Upload EXE artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Bonding_EXE_Artifacts
          path: |
            dist/BondingClient.exe
            dist/BondingServer.exe
            dist/BondingEngineClient.exe
            dist/BondingEngineServer.exe
