name: build-bonding-full-selfcontained

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch: {}

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate project (code + requirements)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path client | Out-Null
          New-Item -ItemType Directory -Force -Path server | Out-Null
          New-Item -ItemType Directory -Force -Path engine | Out-Null

          @"
          PyQt5>=5.15,<6
          psutil>=5.9
          "@ | Set-Content -Encoding UTF8 requirements.txt

          @"
          import sys, time, threading, socket, subprocess, platform, os
          def log(*a):
              ts = time.strftime("%Y-%m-%d %H:%M:%S")
              msg = " ".join(str(x) for x in a)
              sys.stdout.write(f"[{ts}] {msg}\n"); sys.stdout.flush()
          def ping(host, timeout=1000):
              try:
                  if platform.system().lower().startswith("win"):
                      r = subprocess.run(["ping","-n","1","-w",str(timeout),host], capture_output=True)
                  else:
                      r = subprocess.run(["ping","-c","1","-W",str(int(timeout/1000)),host], capture_output=True)
                  return r.returncode == 0
              except Exception:
                  return False
          class RateCounter:
              def __init__(self):
                  self.lock = threading.Lock(); self.count = 0; self.last = time.time(); self.rate = 0.0
              def add(self, n=1):
                  with self.lock: self.count += n
              def tick(self):
                  with self.lock:
                      now=time.time(); dt=now-self.last
                      if dt>=1.0:
                          self.rate=self.count/dt; self.count=0; self.last=now; return self.rate
                  return None
          def bundled_ffmpeg_path():
              if getattr(sys, "frozen", False):
                  base = sys._MEIPASS
                  f = os.path.join(base, "ffmpeg.exe")
                  if os.path.exists(f): return f
                  f2 = os.path.join(os.path.dirname(sys.argv[0]), "ffmpeg.exe")
                  if os.path.exists(f2): return f2
              else:
                  here = os.path.dirname(__file__)
                  f3 = os.path.join(here, "..", "ffmpeg.exe")
                  if os.path.exists(f3): return f3
              import shutil
              return shutil.which("ffmpeg")
          "@ | Set-Content -Encoding UTF8 engine/bonding_common.py

          @"
          import sys, json, socket, time, argparse
          from bonding_common import log, RateCounter
          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              args=ap.parse_args()
              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              server_ip = cfg.get('server_ip','127.0.0.1')
              ports     = cfg.get('server_ports',[12001,12002,12003,12004])
              chunk     = int(cfg.get('ts_chunk',1316))
              enable    = cfg.get('enable_paths', [True]*len(ports))
              socks=[]
              for i,p in enumerate(ports):
                  if i<len(enable) and not enable[i]:
                      socks.append(None); continue
                  s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                  s.setblocking(False)
                  socks.append((s,(server_ip,int(p))))
              log('[engine-client] ->', server_ip, ports, 'chunk', chunk)
              rc=RateCounter(); buf=b''; idx=0
              try:
                  while True:
                      data = sys.stdin.buffer.read1(64*1024)
                      if not data:
                          time.sleep(0.01)
                          if rc.tick() is not None:
                              log(f'[engine-client] chunks/s={rc.rate:.1f}')
                          continue
                      buf += data
                      while len(buf)>=chunk:
                          pkt,buf = buf[:chunk], buf[chunk:]
                          for _ in range(len(socks)):
                              i = idx % len(socks); idx+=1
                              if socks[i] is None: continue
                              s,addr = socks[i]
                              try: s.sendto(pkt, addr); rc.add(1); break
                              except Exception: pass
                      if rc.tick() is not None:
                          log(f'[engine-client] chunks/s={rc.rate:.1f}')
              except KeyboardInterrupt:
                  pass
          if __name__=='__main__': main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_client.py

          @"
          import sys, json, socket, time, argparse, select
          from bonding_common import log
          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              args=ap.parse_args()
              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              ports=cfg.get('listen_ports',[12001,12002,12003,12004])
              out_ip,out_port = cfg.get('output_udp',['127.0.0.1',10080])
              socks=[]
              for p in ports:
                  s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
                  s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
                  s.bind(('0.0.0.0',int(p)))
                  s.setblocking(False)
                  socks.append(s)
              out = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
              out_addr=(out_ip,int(out_port))
              total=0; last=time.time()
              log('[engine-server] listen',ports,'->',out_addr)
              try:
                  while True:
                      r,_,_ = select.select(socks,[],[],0.05)
                      for s in r:
                          try:
                              data,addr = s.recvfrom(65536)
                              out.sendto(data,out_addr); total+=1
                          except Exception: pass
                      now=time.time()
                      if now-last>=1.0:
                          log(f'[engine-server] rx_chunks/s={total}'); total=0; last=now
              except KeyboardInterrupt:
                  pass
          if __name__=='__main__': main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_server.py

          @"
          import sys, os, json, subprocess, shutil, time
          from PyQt5.QtWidgets import (QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QListWidget, QListWidgetItem, QFileDialog,
              QFrame, QStyleFactory, QCheckBox, QMessageBox)
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor
          from engine.bonding_common import bundled_ffmpeg_path

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal = QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45)); pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30)); pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52)); pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255)); pal.setColor(QPalette.HighlightedText, Qt.white)
              else: pal = app.palette()
              app.setPalette(pal)

          def bundled_tool(name):
              import shutil
              if getattr(sys, "frozen", False):
                  base = sys._MEIPASS
                  p = os.path.join(base, name)
                  if os.path.exists(p): return p
                  alt = os.path.join(os.path.dirname(sys.argv[0]), name)
                  if os.path.exists(alt): return alt
              else:
                  here = os.path.dirname(__file__)
                  p3 = os.path.join(here, "..", name)
                  if os.path.exists(p3): return p3
              return shutil.which(name)

          class ClientGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Client'); self.resize(1220,860)
                  self.ff=None; self.eng=None; self.preview=None
                  self.current_source = None
                  root=QVBoxLayout(self)
                  top=QHBoxLayout(); ttl=QLabel('Bonding Client'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())
                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  tab_src=QWidget(); sL=QVBoxLayout(tab_src)
                  g_src=QGroupBox('Video Source'); gL=QHBoxLayout(g_src)
                  self.src_mode=QComboBox(); self.src_mode.addItems(['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener'])
                  gL.addWidget(QLabel('Type:')); gL.addWidget(self.src_mode)
                  self.btn_pick=QPushButton('Pick file'); self.btn_pick.clicked.connect(self.pick_file); gL.addWidget(self.btn_pick)
                  self.btn_apply=QPushButton('Apply Source'); self.btn_apply.clicked.connect(self.apply_source); gL.addWidget(self.btn_apply)
                  sL.addWidget(g_src)
                  g_pl=QGroupBox('Playlist'); gpl=QVBoxLayout(g_pl)
                  self.list=QListWidget(); gpl.addWidget(self.list)
                  hb=QHBoxLayout(); b1=QPushButton('Add'); b2=QPushButton('Remove')
                  b1.clicked.connect(self.add_files); b2.clicked.connect(self.remove_files); hb.addWidget(b1); hb.addWidget(b2); gpl.addLayout(hb)
                  sL.addWidget(g_pl)
                  g_prev=QGroupBox('Preview'); gpv=QHBoxLayout(g_prev)
                  self.btn_prev_play = QPushButton('Play Preview'); self.btn_prev_stop = QPushButton('Stop Preview')
                  self.btn_prev_play.clicked.connect(self.preview_play); self.btn_prev_stop.clicked.connect(self.preview_stop)
                  gpv.addWidget(self.btn_prev_play); gpv.addWidget(self.btn_prev_stop)
                  sL.addWidget(g_prev)
                  self.src_info = QLabel('Source: —  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —')
                  self.src_info.setStyleSheet('padding:6px; border:1px solid #3a3f45; border-radius:6px;')
                  sL.addWidget(self.src_info)
                  tabs.addTab(tab_src,'Source')

                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_srv=QGroupBox('Server & Paths'); gs=QHBoxLayout(g_srv)
                  self.server_ip=QLineEdit('127.0.0.1'); self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(1,8); self.paths.setValue(4); self.ts_chunk=QSpinBox(); self.ts_chunk.setRange(188,4096); self.ts_chunk.setValue(1316)
                  gs.addWidget(QLabel('Server IP:')); gs.addWidget(self.server_ip)
                  gs.addWidget(QLabel('Base port:')); gs.addWidget(self.base_port)
                  gs.addWidget(QLabel('Paths:')); gs.addWidget(self.paths)
                  gs.addWidget(QLabel('TS chunk:')); gs.addWidget(self.ts_chunk)
                  nL.addWidget(g_srv)
                  g_paths=QGroupBox('Per-path enable'); gp=QHBoxLayout(g_paths)
                  self.path_enable=[QCheckBox(f'Path{i+1}') for i in range(8)]
                  for i,cb in enumerate(self.path_enable):
                      if i<4: cb.setChecked(True)
                      gp.addWidget(cb)
                  nL.addWidget(g_paths); tabs.addTab(tab_net,'Network')

                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_enc=QGroupBox('Encoding'); ge=QHBoxLayout(g_enc)
                  self.vcodec=QComboBox(); self.vcodec.addItems(['libx264','h264_nvenc','libx265'])
                  self.profile=QComboBox(); self.profile.addItems(['baseline','main','high'])
                  self.vbit=QSpinBox(); self.vbit.setRange(500,20000); self.vbit.setValue(6000)
                  self.preset=QComboBox(); self.preset.addItems(['ultrafast','veryfast','faster','fast','medium'])
                  for w in (QLabel('Codec:'),self.vcodec,QLabel('Profile:'),self.profile,QLabel('Bitrate kbps:'),self.vbit,QLabel('Preset:'),self.preset): ge.addWidget(w)
                  oL.addWidget(g_enc)
                  g_proto=QGroupBox('Output protocol (for server publish)'); gp2=QHBoxLayout(g_proto)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
                  self.srt_url=QLineEdit('srt://127.0.0.1:9999?mode=caller')
                  gp2.addWidget(QLabel('Protocol:')); gp2.addWidget(self.proto); gp2.addWidget(QLabel('URL:')); gp2.addWidget(self.srt_url)
                  oL.addWidget(g_proto); tabs.addTab(tab_out,'Streaming')

                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;')
                  lL.addWidget(self.logs,1); tabs.addTab(tab_log,'Logs')

                  bb=QHBoxLayout(); bb.addStretch(1); self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop'); bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)
                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
                  apply_theme(self.app,'Light')
                  self.apply_source(initial=True)

              def log(self,msg):
                  ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
                  self.logs.appendPlainText(f'[{ts}] {msg}')
              def _ffmpeg(self): return bundled_tool('ffmpeg.exe')
              def _ffprobe(self): return bundled_tool('ffprobe.exe')
              def _ffplay(self):  return bundled_tool('ffplay.exe')

              def pick_file(self):
                  p,_=QFileDialog.getOpenFileName(self,'Pick video','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  if p: self.list.addItem(QListWidgetItem(p))
              def add_files(self):
                  files,_=QFileDialog.getOpenFileNames(self,'Add to playlist','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  for f in files: self.list.addItem(QListWidgetItem(f))
              def remove_files(self):
                  for it in self.list.selectedItems():
                      self.list.takeItem(self.list.row(it))

              def apply_source(self, initial=False):
                  new_idx = self.src_mode.currentIndex()
                  new_desc = self._source_desc(new_idx)
                  if not initial:
                      reply = QMessageBox.question(self, 'Apply Source', f'Switch source to: {new_desc}?', QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                      if reply != QMessageBox.Yes: return
                  self.current_source = new_idx
                  self.log(f'Applied source: {new_desc}')
                  self.update_source_info()

              def _source_desc(self, idx):
                  names = ['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener']
                  return names[idx] if 0 <= idx < len(names) else 'Unknown'

              def update_source_info(self):
                  fmt='—'; v='—'; fps='—'; a='—'
                  ffprobe = self._ffprobe()
                  if not ffprobe:
                      self.src_info.setText(f'Source: {self._source_desc(self.current_source)}  |  Format: ?  |  Video: ?  |  FPS: ?  |  Audio: ?')
                      return
                  try:
                      if self.current_source == 0:
                          if self.list.count() == 0:
                              self.src_info.setText('Source: File/Playlist  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —'); return
                          path = self.list.item(0).text()
                          out = subprocess.check_output([ffprobe, '-v', 'error', '-select_streams', 'v:0',
                                                         '-show_entries', 'stream=width,height,avg_frame_rate',
                                                         '-of', 'default=noprint_wrappers=1:nokey=1', path], stderr=subprocess.STDOUT)
                          parts = out.decode(errors='ignore').strip().splitlines()
                          if len(parts) >= 3:
                              w,h,fr = parts[0], parts[1], parts[2]
                              v=f'{w}x{h}'; fps = fr if '/' not in fr else self._fps_str(fr)
                          out2 = subprocess.check_output([ffprobe,'-v','error','-select_streams','a:0',
                                                          '-show_entries','stream=sample_rate,channels',
                                                          '-of','default=noprint_wrappers=1:nokey=1', path], stderr=subprocess.STDOUT)
                          aparts = out2.decode(errors='ignore').strip().splitlines()
                          if len(aparts)>=2: a = f'{aparts[1]}ch @ {aparts[0]}Hz'
                          fmt = os.path.splitext(path)[1].lstrip('.').upper()
                      elif self.current_source == 1:
                          fmt='DShow'; v,fps,a='n/a','n/a','n/a'
                      elif self.current_source == 2:
                          fmt='DShow(vMix)'; v,fps,a='n/a','n/a','n/a'
                      elif self.current_source == 3:
                          fmt='NDI'; v,fps,a='n/a','n/a','n/a'
                      else:
                          fmt='SRT listener'; v,fps,a='dynamic','dynamic','dynamic'
                  except Exception as e:
                      self.log(f'ffprobe error: {e}')
                  self.src_info.setText(f'Source: {self._source_desc(self.current_source)}  |  Format: {fmt}  |  Video: {v}  |  FPS: {fps}  |  Audio: {a}')

              def _fps_str(self, fr):
                  try:
                      num, den = fr.split('/')
                      den = float(den) if float(den)!=0 else 1.0
                      return f'{float(num)/den:.2f}'
                  except Exception:
                      return fr

              def preview_play(self):
                  self.preview_stop()
                  ply = self._ffplay()
                  if not ply:
                      QMessageBox.warning(self,'Preview','ffplay.exe not found in bundle.'); return
                  mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
                  cmd = [ply, '-hide_banner', '-loglevel', 'error']
                  if mode == 0:
                      if self.list.count() == 0: self.log('Add files to preview.'); return
                      path = self.list.item(0).text(); cmd += [path]
                  elif mode == 1:
                      cmd += ['-f','dshow','-i','video=Integrated Camera']
                  elif mode == 2:
                      cmd += ['-f','dshow','-i','video=vMix Video']
                  elif mode == 3:
                      self.log('NDI preview: ensure NDI Runtime installed.')
                      cmd += ['-f','libndi_newtek','-i','NDI Source Name']
                  else:
                      cmd += ['srt://0.0.0.0:9999?mode=listener']
                  try:
                      self.preview = subprocess.Popen(cmd); self.log('Preview started')
                  except Exception as e:
                      self.log(f'Preview error: {e}')

              def preview_stop(self):
                  if self.preview and self.preview.poll() is None:
                      try: self.preview.terminate()
                      except: pass
                  self.preview = None

              def _write_client_cfg(self, path):
                  ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
                  enables=[self.path_enable[i].isChecked() for i in range(int(self.paths.value()))]
                  cfg={'server_ip': self.server_ip.text().strip(),'server_ports': ports,'ts_chunk': int(self.ts_chunk.value()),'enable_paths': enables}
                  open(path,'w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2)); return cfg

              def start_all(self):
                  self.stop_all()
                  ff=self._ffmpeg()
                  if not ff: 
                      QMessageBox.warning(self,'FFmpeg','ffmpeg.exe not found in bundle.'); return
                  mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
                  cmd=[ff,'-hide_banner','-re']
                  if mode==0:
                      items=[self.list.item(i).text() for i in range(self.list.count())]
                      if not items: self.log('Add files to playlist.'); return
                      open('playlist.txt','w',encoding='utf-8').write("\n".join([f"file '{p}'" for p in items]))
                      cmd+=['-f','concat','-safe','0','-i','playlist.txt']
                  elif mode==1:
                      cmd+=['-f','dshow','-i','video=Integrated Camera']
                  elif mode==2:
                      cmd+=['-f','dshow','-i','video=vMix Video']
                  elif mode==3:
                      self.log('NDI selected. Ensure NDI Runtime (NDI Tools) is installed.')
                      cmd+=['-f','libndi_newtek','-i','NDI Source Name']
                  else:
                      cmd+=['-i','srt://0.0.0.0:9999?mode=listener']
                  cmd+=['-vcodec',self.vcodec.currentText(),'-profile:v',self.profile.currentText(),'-b:v',f"{self.vbit.value()}k",
                        '-preset',self.preset.currentText(),'-acodec','aac','-b:a','128k','-f','mpegts','-']
                  try:
                      self.ff = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('ffmpeg started (bundled)')
                  except Exception as e:
                      self.log(f'ffmpeg error: {e}'); return
                  cfg_path='bonding_client.json'; self._write_client_cfg(cfg_path)
                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineClient.exe')
                  if not os.path.exists(engine): self.log('BondingEngineClient.exe not found'); return
                  try:
                      self.eng = subprocess.Popen([engine,'--config',cfg_path], stdin=self.ff.stdout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('engine client started')
                  except Exception as e:
                      self.log(f'engine error: {e}')

              def stop_all(self):
                  self.preview_stop()
                  for p in [self.eng,self.ff]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.eng=None; self.ff=None; self.log('Stopped')

              def _pump_logs(self):
                  for p in [self.ff,self.eng]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ClientGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 client/client_gui.py

          @"
          import sys, os, json, subprocess, shutil, time
          from PyQt5.QtWidgets import (QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QStyleFactory, QFrame, QMessageBox)
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor
          from engine.bonding_common import bundled_ffmpeg_path

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal=QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45)); pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30)); pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52)); pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255)); pal.setColor(QPalette.HighlightedText, Qt.white)
              else: pal = app.palette()
              app.setPalette(pal)

          def bundled_tool(name):
              import shutil, sys, os
              if getattr(sys, "frozen", False):
                  base = sys._MEIPASS
                  p = os.path.join(base, name)
                  if os.path.exists(p): return p
                  alt = os.path.join(os.path.dirname(sys.argv[0]), name)
                  if os.path.exists(alt): return alt
              else:
                  here = os.path.dirname(__file__)
                  p3 = os.path.join(here, "..", name)
                  if os.path.exists(p3): return p3
              return shutil.which(name)

          class ServerGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Server'); self.resize(1100,780)
                  self.eng=None; self.pub=None
                  root=QVBoxLayout(self)
                  top=QHBoxLayout(); ttl=QLabel('Bonding Server'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())
                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_listen=QGroupBox('Listen ports'); gL=QHBoxLayout(g_listen)
                  self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(1,8); self.paths.setValue(4)
                  self.group_udp_port=QSpinBox(); self.group_udp_port.setRange(1000,65535); self.group_udp_port.setValue(10080)
                  gL.addWidget(QLabel('Base port:')); gL.addWidget(self.base_port)
                  gL.addWidget(QLabel('Paths:')); gL.addWidget(self.paths)
                  gL.addWidget(QLabel('Merge to UDP port:')); gL.addWidget(self.group_udp_port)
                  nL.addWidget(g_listen); tabs.addTab(tab_net,'Network')

                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_pub=QGroupBox('Publish'); gp=QHBoxLayout(g_pub)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
                  self.srt_host=QLineEdit('0.0.0.0'); self.srt_port=QSpinBox(); self.srt_port.setRange(1000,65535); self.srt_port.setValue(9999)
                  self.srt_mode=QComboBox(); self.srt_mode.addItems(['listener','caller'])
                  self.rtmp_url=QLineEdit('rtmp://live.twitch.tv/app/STREAM_KEY')
                  for w in (QLabel('Protocol:'),self.proto,QLabel('SRT host:'),self.srt_host,QLabel('port:'),self.srt_port,QLabel('mode:'),self.srt_mode,QLabel('RTMP URL:'),self.rtmp_url): gp.addWidget(w)
                  oL.addWidget(g_pub); tabs.addTab(tab_out,'Streaming')

                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;')
                  lL.addWidget(self.logs,1); tabs.addTab(tab_log,'Logs')

                  bb=QHBoxLayout(); bb.addStretch(1); self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop'); bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)
                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
                  apply_theme(self.app,'Light')

              def _ffmpeg(self): return bundled_tool('ffmpeg.exe')

              def start_all(self):
                  self.stop_all()
                  ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
                  cfg={'listen_ports': ports, 'output_udp': ['127.0.0.1', int(self.group_udp_port.value())]}
                  open('bonding_server.json','w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2))
                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineServer.exe')
                  if not os.path.exists(engine): self.log('BondingEngineServer.exe not found'); return
                  try:
                      self.eng=subprocess.Popen([engine,'--config','bonding_server.json'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('engine server started')
                  except Exception as e: self.log(f'engine error: {e}'); return
                  ff=self._ffmpeg()
                  if not ff: 
                      QMessageBox.warning(self,'FFmpeg','ffmpeg.exe not found in bundle.'); return
                  src=f'udp://127.0.0.1:{int(self.group_udp_port.value())}?fifo_size=1000000&overrun_nonfatal=1'
                  cmd=[ff,'-hide_banner','-fflags','nobuffer','-i',src,'-c:a','aac','-b:a','128k']
                  if self.proto.currentText()=='SRT':
                      out=f'srt://{self.srt_host.text().strip()}:{int(self.srt_port.value())}?mode={self.srt_mode.currentText()}'
                      cmd+=['-c:v','copy','-f','mpegts',out]
                  else:
                      cmd+=['-c:v','libx264','-preset','veryfast','-b:v','6000k','-f','flv',self.rtmp_url.text().strip()]
                  try:
                      self.pub=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('publish started (bundled ffmpeg)')
                  except Exception as e:
                      self.log(f'publish error: {e}')

              def stop_all(self):
                  for p in [self.pub,self.eng]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.pub=None; self.eng=None; self.log('Stopped')

              def _pump_logs(self):
                  for p in [self.eng,self.pub]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass

              def log(self,msg):
                  ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
                  self.logs.appendPlainText(f'[{ts}] {msg}')

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ServerGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 server/server_gui.py

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Download FFmpeg (win64 GPL) and extract binaries
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest"
          $asset = $rel.assets | Where-Object { $_.name -like "ffmpeg-master-latest-win64-gpl.zip" } | Select-Object -First 1
          if(-not $asset){ throw "FFmpeg asset not found in latest release." }
          $zip = Join-Path $env:RUNNER_TEMP $asset.name
          Invoke-WebRequest -Uri $asset.browser_download_url -OutFile $zip
          Expand-Archive -Path $zip -DestinationPath "$env:RUNNER_TEMP\ffm" -Force
          $exe = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffmpeg.exe | Select-Object -First 1
          $prb = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffprobe.exe | Select-Object -First 1
          $ply = Get-ChildItem -Recurse "$env:RUNNER_TEMP\ffm" -Filter ffplay.exe | Select-Object -First 1
          if(-not $exe -or -not $prb -or -not $ply){ throw "ffmpeg/ffprobe/ffplay not found in archive." }
          Copy-Item $exe.FullName -Destination "$PWD\ffmpeg.exe"
          Copy-Item $prb.FullName -Destination "$PWD\ffprobe.exe"
          Copy-Item $ply.FullName -Destination "$PWD\ffplay.exe"
          Write-Host "FFmpeg/FFprobe/FFplay copied to repo root."

      - name: Build engines (console)
        run: |
          pyinstaller -F engine/bonding_engine_client.py -n BondingEngineClient
          pyinstaller -F engine/bonding_engine_server.py -n BondingEngineServer

      - name: Build GUIs (windowed) with bundled FFmpeg
        run: |
          pyinstaller -w -F client/client_gui.py -n BondingClient --add-binary "ffmpeg.exe;." --add-binary "ffprobe.exe;." --add-binary "ffplay.exe;."
          pyinstaller -w -F server/server_gui.py -n BondingServer --add-binary "ffmpeg.exe;." --add-binary "ffprobe.exe;." --add-binary "ffplay.exe;."

      - name: Upload EXE artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Bonding_EXE_Artifacts
          path: |
            dist/BondingClient.exe
            dist/BondingServer.exe
            dist/BondingEngineClient.exe
            dist/BondingEngineServer.exe
