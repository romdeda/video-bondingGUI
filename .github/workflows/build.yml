name: Build Bonding (full)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate project (client/server/engine + reqs)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force client, server, engine | Out-Null

          # requirements.txt
          @"
          PyQt5>=5.15,<6
          psutil>=5.9
          "@ | Set-Content -Encoding UTF8 requirements.txt

          # engine/bonding_common.py
          @"
          import sys, time, threading, socket, subprocess, platform

          def log(*a):
              ts = time.strftime("%Y-%m-%d %H:%M:%S")
              msg = " ".join(str(x) for x in a)
              sys.stdout.write(f"[{ts}] {msg}\n"); sys.stdout.flush()

          def ping(host, timeout=1000):
              try:
                  if platform.system().lower().startswith("win"):
                      # -n 1 (one echo), -w timeout(ms)
                      r = subprocess.run(["ping","-n","1","-w",str(timeout),host], capture_output=True)
                  else:
                      r = subprocess.run(["ping","-c","1","-W",str(int(timeout/1000)),host], capture_output=True)
                  return r.returncode == 0
              except Exception:
                  return False

          class RateCounter:
              def __init__(self):
                  self.lock = threading.Lock()
                  self.count = 0
                  self.last = time.time()
                  self.rate = 0.0
              def add(self, n=1): 
                  with self.lock: self.count += n
              def tick(self):
                  with self.lock:
                      now=time.time(); dt=now-self.last
                      if dt>=1.0:
                          self.rate=self.count/dt; self.count=0; self.last=now; return self.rate
                  return None
          "@ | Set-Content -Encoding UTF8 engine/bonding_common.py

          # engine/bonding_engine_client.py  (распределяет TS-байты по нескольким UDP-путям)
          @"
          import sys, json, socket, time, argparse, itertools
          from bonding_common import log, RateCounter

          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              args=ap.parse_args()
              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              server_ip = cfg.get('server_ip','127.0.0.1')
              ports     = cfg.get('server_ports',[12001,12002,12003,12004])
              chunk     = int(cfg.get('ts_chunk',1316))
              enable    = cfg.get('enable_paths', [True]*len(ports))

              socks=[]
              for i,p in enumerate(ports):
                  if i<len(enable) and not enable[i]: 
                      socks.append(None); continue
                  s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                  s.setblocking(False)
                  socks.append((s,(server_ip,int(p))))

              log('[engine-client] ->', server_ip, ports, 'chunk', chunk)
              rc=RateCounter()
              buf=b''; idx=0
              try:
                  while True:
                      data = sys.stdin.buffer.read1(64*1024)
                      if not data:
                          time.sleep(0.01); 
                          if rc.tick() is not None:
                              log(f'[engine-client] chunks/s={rc.rate:.1f}')
                          continue
                      buf += data
                      while len(buf)>=chunk:
                          pkt,buf = buf[:chunk], buf[chunk:]
                          # round-robin по активным путям
                          for _ in range(len(socks)):
                              i=idx%len(socks); idx+=1
                              if socks[i] is None: 
                                  continue
                              s,addr = socks[i]
                              try:
                                  s.sendto(pkt, addr); rc.add(1)
                                  break
                              except Exception:
                                  pass
                      if rc.tick() is not None:
                          log(f'[engine-client] chunks/s={rc.rate:.1f}')
              except KeyboardInterrupt:
                  pass

          if __name__=='__main__': 
              main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_client.py

          # engine/bonding_engine_server.py  (принимает с нескольких портов и склеивает в один UDP)
          @"
          import sys, json, socket, time, argparse, select
          from bonding_common import log

          def main():
              ap=argparse.ArgumentParser()
              ap.add_argument('--config', required=True)
              args=ap.parse_args()
              cfg=json.load(open(args.config,'r',encoding='utf-8'))
              ports=cfg.get('listen_ports',[12001,12002,12003,12004])
              out_ip,out_port = cfg.get('output_udp',['127.0.0.1',10080])

              socks=[]
              for p in ports:
                  s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
                  s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
                  s.bind(('0.0.0.0',int(p)))
                  s.setblocking(False)
                  socks.append(s)
              out = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
              out_addr=(out_ip,int(out_port))
              total=0; last=time.time()
              log('[engine-server] listen',ports,'->',out_addr)
              try:
                  while True:
                      r,_,_ = select.select(socks,[],[],0.05)
                      for s in r:
                          try:
                              data,addr = s.recvfrom(65536)
                              out.sendto(data,out_addr); total+=1
                          except Exception:
                              pass
                      now=time.time()
                      if now-last>=1.0:
                          log(f'[engine-server] rx_chunks/s={total}'); total=0; last=now
              except KeyboardInterrupt:
                  pass

          if __name__=='__main__':
              main()
          "@ | Set-Content -Encoding UTF8 engine/bonding_engine_server.py

          # client/client_gui.py  (вкладки: Source / Network / Streaming / Logs, SRT/RTMP, плейлист, мониторинг)
          @"
          import sys, os, json, subprocess, shutil, threading, time
          from PyQt5.QtWidgets import (QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QListWidget, QListWidgetItem, QFileDialog, 
              QFrame, QStyleFactory, QCheckBox)
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor
          import psutil

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal = QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45)); pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30)); pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52)); pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255)); pal.setColor(QPalette.HighlightedText, Qt.white)
              else: pal = app.palette()
              app.setPalette(pal)

          class ClientGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Client'); self.resize(1180,820)
                  self.ff=None; self.eng=None
                  root=QVBoxLayout(self)

                  top=QHBoxLayout(); ttl=QLabel('Bonding Client'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())

                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  # Source
                  tab_src=QWidget(); sL=QVBoxLayout(tab_src)
                  g_src=QGroupBox('Video Source'); gL=QHBoxLayout(g_src)
                  self.src_mode=QComboBox(); self.src_mode.addItems(['File/Playlist','Camera (DirectShow)','vMix Video','NDI (placeholder)','SRT Listener'])
                  gL.addWidget(QLabel('Type:')); gL.addWidget(self.src_mode)
                  self.btn_pick=QPushButton('Pick file'); self.btn_pick.clicked.connect(self.pick_file); gL.addWidget(self.btn_pick)
                  sL.addWidget(g_src)

                  g_pl=QGroupBox('Playlist'); gpl=QVBoxLayout(g_pl)
                  self.list=QListWidget(); gpl.addWidget(self.list)
                  hb=QHBoxLayout(); b1=QPushButton('Add'); b2=QPushButton('Remove')
                  b1.clicked.connect(self.add_files); b2.clicked.connect(self.remove_files); hb.addWidget(b1); hb.addWidget(b2); gpl.addLayout(hb)
                  sL.addWidget(g_pl)
                  tabs.addTab(tab_src,'Source')

                  # Network
                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_srv=QGroupBox('Server & Paths'); gs=QHBoxLayout(g_srv)
                  self.server_ip=QLineEdit('127.0.0.1'); self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(1,8); self.paths.setValue(4); self.ts_chunk=QSpinBox(); self.ts_chunk.setRange(188,4096); self.ts_chunk.setValue(1316)
                  gs.addWidget(QLabel('Server IP:')); gs.addWidget(self.server_ip)
                  gs.addWidget(QLabel('Base port:')); gs.addWidget(self.base_port)
                  gs.addWidget(QLabel('Paths:')); gs.addWidget(self.paths)
                  gs.addWidget(QLabel('TS chunk:')); gs.addWidget(self.ts_chunk)
                  nL.addWidget(g_srv)

                  g_paths=QGroupBox('Per-path enable'); gp=QHBoxLayout(g_paths)
                  self.path_enable=[QCheckBox(f'Path{i+1}') for i in range(8)]
                  for i,cb in enumerate(self.path_enable): 
                      if i<4: cb.setChecked(True)
                      gp.addWidget(cb)
                  nL.addWidget(g_paths)
                  tabs.addTab(tab_net,'Network')

                  # Streaming (encode + protocol)
                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_enc=QGroupBox('Encoding'); ge=QHBoxLayout(g_enc)
                  self.vcodec=QComboBox(); self.vcodec.addItems(['libx264','h264_nvenc','libx265'])
                  self.profile=QComboBox(); self.profile.addItems(['baseline','main','high'])
                  self.vbit=QSpinBox(); self.vbit.setRange(500,20000); self.vbit.setValue(6000)
                  self.preset=QComboBox(); self.preset.addItems(['ultrafast','veryfast','faster','fast','medium'])
                  for w in (QLabel('Codec:'),self.vcodec,QLabel('Profile:'),self.profile,QLabel('Bitrate kbps:'),self.vbit,QLabel('Preset:'),self.preset): ge.addWidget(w)
                  oL.addWidget(g_enc)

                  g_proto=QGroupBox('Output protocol'); gp2=QHBoxLayout(g_proto)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
                  self.srt_url=QLineEdit('srt://127.0.0.1:9999?mode=caller')  # для RTMP сюда вставь rtmp URL
                  gp2.addWidget(QLabel('Protocol:')); gp2.addWidget(self.proto); gp2.addWidget(QLabel('URL:')); gp2.addWidget(self.srt_url)
                  oL.addWidget(g_proto); tabs.addTab(tab_out,'Streaming')

                  # Logs
                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;')
                  lL.addWidget(self.logs,1); tabs.addTab(tab_log,'Logs')

                  # bottom
                  bb=QHBoxLayout(); bb.addStretch(1)
                  self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop')
                  bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)

                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
                  apply_theme(self.app,'Light')

              def _ffmpeg(self):
                  exe=os.path.join(os.path.dirname(sys.argv[0]),'ffmpeg.exe')
                  if os.path.exists(exe): return exe
                  p=shutil.which('ffmpeg')
                  return p

              def pick_file(self):
                  p,_=QFileDialog.getOpenFileName(self,'Pick video','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  if p: self.list.addItem(QListWidgetItem(p))
              def add_files(self):
                  files,_=QFileDialog.getOpenFileNames(self,'Add to playlist','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
                  for f in files: self.list.addItem(QListWidgetItem(f))
              def remove_files(self):
                  for it in self.list.selectedItems(): self.list.takeItem(self.list.row(it))

              def _write_client_cfg(self, path):
                  ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
                  enables=[self.path_enable[i].isChecked() for i in range(int(self.paths.value()))]
                  cfg={'server_ip': self.server_ip.text().strip(),'server_ports': ports,'ts_chunk': int(self.ts_chunk.value()),'enable_paths': enables}
                  open(path,'w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2)); return cfg

              def start_all(self):
                  self.stop_all()
                  ff=self._ffmpeg()
                  if ff is None:
                      self.log('ffmpeg not found (place ffmpeg.exe next to EXE or add to PATH).'); return
                  mode=self.src_mode.currentIndex()
                  cmd=[ff,'-hide_banner','-re']  # -re для файлов/плейлиста (эмулирует realtime)

                  if mode==0:
                      items=[self.list.item(i).text() for i in range(self.list.count())]
                      if not items: self.log('Add files to playlist.'); return
                      open('playlist.txt','w',encoding='utf-8').write("\n".join([f"file '{p}'" for p in items]))
                      cmd+=['-f','concat','-safe','0','-i','playlist.txt']
                  elif mode==1:
                      cmd+=['-f','dshow','-i','video=Integrated Camera']  # замени на свой источник
                  elif mode==2:
                      cmd+=['-f','dshow','-i','video=vMix Video']        # vMix Video (DirectShow)
                  elif mode==3:
                      cmd+=['-f','libndi_newtek','-i','NDI Source Name'] # нужен NDI runtime рядом
                  else:
                      cmd+=['-i','srt://0.0.0.0:9999?mode=listener']

                  # кодек/битрейт
                  cmd+=['-vcodec',self.vcodec.currentText(),'-profile:v',self.profile.currentText(),'-b:v',f"{self.vbit.value()}k",'-preset',self.preset.currentText(),
                        '-acodec','aac','-b:a','128k','-f','mpegts','-']

                  try:
                      self.ff = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                      self.log('ffmpeg started')
                  except Exception as e:
                      self.log(f'ffmpeg error: {e}'); return

                  cfg_path='bonding_client.json'; self._write_client_cfg(cfg_path)
                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineClient.exe')
                  if not os.path.exists(engine):
                      self.log('BondingEngineClient.exe not found (build engines).'); return
                  try:
                      self.eng = subprocess.Popen([engine,'--config',cfg_path], stdin=self.ff.stdout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                      self.log('engine client started')
                  except Exception as e:
                      self.log(f'engine error: {e}')

                  # Параллельно публиковать на SRT/RTMP можно отдельным узлом (сервером). Здесь клиент шлёт только на bonding-server.

              def stop_all(self):
                  for p in [self.eng, self.ff]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.eng=None; self.ff=None; self.log('Stopped')

              def _pump_logs(self):
                  for p in [self.ff,self.eng]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass

              def log(self,msg):
                  ts = QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
                  self.logs.appendPlainText(f'[{ts}] {msg}')

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ClientGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 client/client_gui.py

          # server/server_gui.py (слушает пути, склеивает и публикует SRT/RTMP через ffmpeg)
          @"
          import sys, os, json, subprocess, shutil, time
          from PyQt5.QtWidgets import (QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
              QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QStyleFactory, QFrame)
          from PyQt5.QtCore import Qt, QTimer, QDateTime
          from PyQt5.QtGui import QPalette, QColor

          def hline():
              line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
          def apply_theme(app, mode):
              app.setStyle(QStyleFactory.create('Fusion')); pal=QPalette()
              if mode.lower().startswith('dark'):
                  pal.setColor(QPalette.Window, QColor(37,40,45)); pal.setColor(QPalette.WindowText, Qt.white)
                  pal.setColor(QPalette.Base, QColor(24,26,30)); pal.setColor(QPalette.Text, Qt.white)
                  pal.setColor(QPalette.Button, QColor(45,47,52)); pal.setColor(QPalette.ButtonText, Qt.white)
                  pal.setColor(QPalette.Highlight, QColor(64,128,255)); pal.setColor(QPalette.HighlightedText, Qt.white)
              else: pal = app.palette()
              app.setPalette(pal)

          class ServerGUI(QWidget):
              def __init__(self, app):
                  super().__init__(); self.app=app
                  self.setWindowTitle('Bonding Server'); self.resize(1100,780)
                  self.eng=None; self.pub=None
                  root=QVBoxLayout(self)

                  top=QHBoxLayout(); ttl=QLabel('Bonding Server'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
                  top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
                  self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
                  top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())

                  tabs=QTabWidget(); root.addWidget(tabs,1)

                  tab_net=QWidget(); nL=QVBoxLayout(tab_net)
                  g_listen=QGroupBox('Listen ports'); gL=QHBoxLayout(g_listen)
                  self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
                  self.paths=QSpinBox(); self.paths.setRange(1,8); self.paths.setValue(4)
                  self.group_udp_port=QSpinBox(); self.group_udp_port.setRange(1000,65535); self.group_udp_port.setValue(10080)
                  gL.addWidget(QLabel('Base port:')); gL.addWidget(self.base_port)
                  gL.addWidget(QLabel('Paths:')); gL.addWidget(self.paths)
                  gL.addWidget(QLabel('Merge to UDP port:')); gL.addWidget(self.group_udp_port)
                  nL.addWidget(g_listen); tabs.addTab(tab_net,'Network')

                  tab_out=QWidget(); oL=QVBoxLayout(tab_out)
                  g_pub=QGroupBox('Publish'); gp=QHBoxLayout(g_pub)
                  self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
                  self.srt_host=QLineEdit('0.0.0.0'); self.srt_port=QSpinBox(); self.srt_port.setRange(1000,65535); self.srt_port.setValue(9999)
                  self.srt_mode=QComboBox(); self.srt_mode.addItems(['listener','caller'])
                  self.rtmp_url=QLineEdit('rtmp://live.twitch.tv/app/STREAM_KEY')
                  for w in (QLabel('Protocol:'),self.proto,QLabel('SRT host:'),self.srt_host,QLabel('port:'),self.srt_port,QLabel('mode:'),self.srt_mode,QLabel('RTMP URL:'),self.rtmp_url): gp.addWidget(w)
                  oL.addWidget(g_pub); tabs.addTab(tab_out,'Streaming')

                  tab_log=QWidget(); lL=QVBoxLayout(tab_log)
                  self.logs=QPlainTextEdit(); self.logs.setReadOnly(True); self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;')
                  lL.addWidget(self.logs,1); tabs.addTab(tab_log,'Logs')

                  bb=QHBoxLayout(); bb.addStretch(1); self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop'); bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
                  self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)
                  self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
                  apply_theme(self.app,'Light')

              def _ffmpeg(self):
                  exe=os.path.join(os.path.dirname(sys.argv[0]),'ffmpeg.exe')
                  if os.path.exists(exe): return exe
                  p=shutil.which('ffmpeg')
                  return p

              def start_all(self):
                  self.stop_all()
                  # 1) bonding server
                  ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
                  cfg={'listen_ports': ports, 'output_udp': ['127.0.0.1', int(self.group_udp_port.value())]}
                  open('bonding_server.json','w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2))
                  engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineServer.exe')
                  if not os.path.exists(engine): self.log('BondingEngineServer.exe not found'); return
                  try:
                      self.eng=subprocess.Popen([engine,'--config','bonding_server.json'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('engine server started')
                  except Exception as e: self.log(f'engine error: {e}'); return

                  # 2) publish with ffmpeg from merged UDP
                  ff=self._ffmpeg()
                  if ff is None: self.log('ffmpeg not found (place ffmpeg.exe next to EXE or in PATH).'); return
                  src=f'udp://127.0.0.1:{int(self.group_udp_port.value())}?fifo_size=1000000&overrun_nonfatal=1'
                  cmd=[ff,'-hide_banner','-fflags','nobuffer','-i',src,'-c:a','aac','-b:a','128k']
                  if self.proto.currentText()=='SRT':
                      out=f'srt://{self.srt_host.text().strip()}:{int(self.srt_port.value())}?mode={self.srt_mode.currentText()}'
                      cmd+=['-c:v','copy','-f','mpegts',out]
                  else:
                      cmd+=['-c:v','libx264','-preset','veryfast','-b:v','6000k','-f','flv',self.rtmp_url.text().strip()]
                  try:
                      self.pub=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT); self.log('publish started')
                  except Exception as e:
                      self.log(f'publish error: {e}')

              def stop_all(self):
                  for p in [self.pub,self.eng]:
                      if p and p.poll() is None:
                          try: p.terminate()
                          except: pass
                  self.pub=None; self.eng=None; self.log('Stopped')

              def _pump_logs(self):
                  for p in [self.eng,self.pub]:
                      if p and p.stdout:
                          try:
                              line=p.stdout.readline().decode(errors='ignore')
                              if line: self.logs.appendPlainText(line.rstrip())
                          except Exception: pass

              def log(self,msg):
                  ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
                  self.logs.appendPlainText(f'[{ts}] {msg}')

          if __name__=='__main__':
              app=QApplication(sys.argv)
              w=ServerGUI(app); w.show()
              sys.exit(app.exec_())
          "@ | Set-Content -Encoding UTF8 server/server_gui.py

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Build engines
        run: |
          pyinstaller -F engine/bonding_engine_client.py -n BondingEngineClient
          pyinstaller -F engine/bonding_engine_server.py -n BondingEngineServer

      - name: Build GUIs
        run: |
          pyinstaller -w -F client/client_gui.py -n BondingClient
          pyinstaller -w -F server/server_gui.py -n BondingServer

      - name: Upload EXE artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Bonding_EXE_Artifacts
          path: |
            dist/BondingClient.exe
            dist/BondingServer.exe
            dist/BondingEngineClient.exe
            dist/BondingEngineServer.exe
