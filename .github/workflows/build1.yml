import sys, os, json, subprocess, shutil, time
from PyQt5.QtWidgets import (
    QApplication, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QGroupBox, QLineEdit, QSpinBox, QComboBox, QPlainTextEdit, QListWidget, QListWidgetItem,
    QFileDialog, QFrame, QStyleFactory, QCheckBox, QMessageBox
)
from PyQt5.QtCore import Qt, QTimer, QDateTime
from PyQt5.QtGui import QPalette, QColor
from engine.bonding_common import bundled_ffmpeg_path

def hline():
    line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken); return line
def apply_theme(app, mode):
    app.setStyle(QStyleFactory.create('Fusion'))
    pal = QPalette()
    if mode.lower().startswith('dark'):
        pal.setColor(QPalette.Window, QColor(37,40,45))
        pal.setColor(QPalette.WindowText, Qt.white)
        pal.setColor(QPalette.Base, QColor(24,26,30))
        pal.setColor(QPalette.Text, Qt.white)
        pal.setColor(QPalette.Button, QColor(45,47,52))
        pal.setColor(QPalette.ButtonText, Qt.white)
        pal.setColor(QPalette.Highlight, QColor(64,128,255))
        pal.setColor(QPalette.HighlightedText, Qt.white)
    else:
        pal = app.palette()
    app.setPalette(pal)

def bundled_tool(name):
    """
    Возвращает путь к встроенным ffmpeg/ffprobe/ffplay (упакованы PyInstaller'ом via --add-binary "tool.exe;.")
    """
    if getattr(sys, "frozen", False):
        base = sys._MEIPASS
        p = os.path.join(base, name)
        if os.path.exists(p): return p
        alt = os.path.join(os.path.dirname(sys.argv[0]), name)
        if os.path.exists(alt): return alt
    else:
        here = os.path.dirname(__file__)
        p3 = os.path.join(here, "..", name)
        if os.path.exists(p3): return p3
    return shutil.which(name)

class ClientGUI(QWidget):
    def __init__(self, app):
        super().__init__(); self.app=app
        self.setWindowTitle('Bonding Client'); self.resize(1220,860)
        self.ff=None; self.eng=None; self.preview=None
        self.current_source = None  # логический источник, применяем только после Apply
        root=QVBoxLayout(self)
        # header
        top=QHBoxLayout(); ttl=QLabel('Bonding Client'); ttl.setStyleSheet('font-size:16pt; font-weight:700')
        top.addWidget(ttl); top.addStretch(1); top.addWidget(QLabel('Theme'))
        self.theme=QComboBox(); self.theme.addItems(['Light','Dark']); self.theme.currentTextChanged.connect(lambda m: apply_theme(self.app,m))
        top.addWidget(self.theme); root.addLayout(top); root.addWidget(hline())
        tabs=QTabWidget(); root.addWidget(tabs,1)

        # ===== Tab: Source =====
        tab_src=QWidget(); sL=QVBoxLayout(tab_src)
        g_src=QGroupBox('Video Source'); gL=QHBoxLayout(g_src)
        self.src_mode=QComboBox(); self.src_mode.addItems(['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener'])
        gL.addWidget(QLabel('Type:')); gL.addWidget(self.src_mode)
        self.btn_pick=QPushButton('Pick file'); self.btn_pick.clicked.connect(self.pick_file); gL.addWidget(self.btn_pick)
        self.btn_apply=QPushButton('Apply Source'); self.btn_apply.clicked.connect(self.apply_source); gL.addWidget(self.btn_apply)
        sL.addWidget(g_src)

        g_pl=QGroupBox('Playlist'); gpl=QVBoxLayout(g_pl)
        self.list=QListWidget(); gpl.addWidget(self.list)
        hb=QHBoxLayout(); b1=QPushButton('Add'); b2=QPushButton('Remove')
        b1.clicked.connect(self.add_files); b2.clicked.connect(self.remove_files); hb.addWidget(b1); hb.addWidget(b2); gpl.addLayout(hb)
        sL.addWidget(g_pl)

        # Preview controls
        g_prev=QGroupBox('Preview'); gpv=QHBoxLayout(g_prev)
        self.btn_prev_play = QPushButton('Play Preview')
        self.btn_prev_stop = QPushButton('Stop Preview')
        self.btn_prev_play.clicked.connect(self.preview_play)
        self.btn_prev_stop.clicked.connect(self.preview_stop)
        gpv.addWidget(self.btn_prev_play); gpv.addWidget(self.btn_prev_stop)
        sL.addWidget(g_prev)

        # source info (status bar emulation)
        self.src_info = QLabel('Source: —  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —')
        self.src_info.setStyleSheet('padding:6px; border:1px solid #3a3f45; border-radius:6px;')
        sL.addWidget(self.src_info)

        tabs.addTab(tab_src,'Source')

        # ===== Tab: Network =====
        tab_net=QWidget(); nL=QVBoxLayout(tab_net)
        g_srv=QGroupBox('Server & Paths'); gs=QHBoxLayout(g_srv)
        self.server_ip=QLineEdit('127.0.0.1')
        self.base_port=QSpinBox(); self.base_port.setRange(1000,65535); self.base_port.setValue(12001)
        self.paths=QSpinBox(); self.paths.setRange(1,8); self.paths.setValue(4)
        self.ts_chunk=QSpinBox(); self.ts_chunk.setRange(188,4096); self.ts_chunk.setValue(1316)
        gs.addWidget(QLabel('Server IP:')); gs.addWidget(self.server_ip)
        gs.addWidget(QLabel('Base port:')); gs.addWidget(self.base_port)
        gs.addWidget(QLabel('Paths:')); gs.addWidget(self.paths)
        gs.addWidget(QLabel('TS chunk:')); gs.addWidget(self.ts_chunk)
        nL.addWidget(g_srv)
        g_paths=QGroupBox('Per-path enable'); gp=QHBoxLayout(g_paths)
        self.path_enable=[QCheckBox(f'Path{i+1}') for i in range(8)]
        for i,cb in enumerate(self.path_enable):
            if i<4: cb.setChecked(True)
            gp.addWidget(cb)
        nL.addWidget(g_paths)
        tabs.addTab(tab_net,'Network')

        # ===== Tab: Streaming =====
        tab_out=QWidget(); oL=QVBoxLayout(tab_out)
        g_enc=QGroupBox('Encoding'); ge=QHBoxLayout(g_enc)
        self.vcodec=QComboBox(); self.vcodec.addItems(['libx264','h264_nvenc','libx265'])
        self.profile=QComboBox(); self.profile.addItems(['baseline','main','high'])
        self.vbit=QSpinBox(); self.vbit.setRange(500,20000); self.vbit.setValue(6000)
        self.preset=QComboBox(); self.preset.addItems(['ultrafast','veryfast','faster','fast','medium'])
        for w in (QLabel('Codec:'),self.vcodec,QLabel('Profile:'),self.profile,QLabel('Bitrate kbps:'),self.vbit,QLabel('Preset:'),self.preset):
            ge.addWidget(w)
        oL.addWidget(g_enc)
        g_proto=QGroupBox('Output protocol (for server publish)'); gp2=QHBoxLayout(g_proto)
        self.proto=QComboBox(); self.proto.addItems(['SRT','RTMP'])
        self.srt_url=QLineEdit('srt://127.0.0.1:9999?mode=caller')
        gp2.addWidget(QLabel('Protocol:')); gp2.addWidget(self.proto); gp2.addWidget(QLabel('URL:')); gp2.addWidget(self.srt_url)
        oL.addWidget(g_proto)
        tabs.addTab(tab_out,'Streaming')

        # ===== Tab: Logs =====
        tab_log=QWidget(); lL=QVBoxLayout(tab_log)
        self.logs=QPlainTextEdit(); self.logs.setReadOnly(True)
        self.logs.setStyleSheet('background:#0b0f14; color:#cde4ff;')
        lL.addWidget(self.logs,1)
        tabs.addTab(tab_log,'Logs')

        # bottom
        bb=QHBoxLayout(); bb.addStretch(1)
        self.btn_start=QPushButton('Start'); self.btn_stop=QPushButton('Stop')
        bb.addWidget(self.btn_start); bb.addWidget(self.btn_stop); root.addLayout(bb)
        self.btn_start.clicked.connect(self.start_all); self.btn_stop.clicked.connect(self.stop_all)

        self.timer=QTimer(self); self.timer.timeout.connect(self._pump_logs); self.timer.start(150)
        apply_theme(self.app,'Light')

        # начальное применение источника
        self.apply_source(initial=True)

    # ---------- utils ----------
    def log(self,msg):
        ts=QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss')
        self.logs.appendPlainText(f'[{ts}] {msg}')

    def _ffmpeg(self):
        # предпочтительно берём встроенный
        ff = bundled_tool('ffmpeg.exe')
        if not ff:
            QMessageBox.warning(self, 'FFmpeg', 'ffmpeg.exe not found inside bundle (unexpected).')
        return ff

    def _ffprobe(self):
        return bundled_tool('ffprobe.exe')

    def _ffplay(self):
        return bundled_tool('ffplay.exe')

    # ---------- source handling ----------
    def pick_file(self):
        p,_=QFileDialog.getOpenFileName(self,'Pick video','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
        if p: self.list.addItem(QListWidgetItem(p))

    def add_files(self):
        files,_=QFileDialog.getOpenFileNames(self,'Add to playlist','','Video (*.mp4 *.mkv *.mov *.ts);;All files (*)')
        for f in files: self.list.addItem(QListWidgetItem(f))

    def remove_files(self):
        for it in self.list.selectedItems():
            self.list.takeItem(self.list.row(it))

    def apply_source(self, initial=False):
        new_idx = self.src_mode.currentIndex()
        new_desc = self._source_desc(new_idx)
        if not initial:
            reply = QMessageBox.question(self, 'Apply Source',
                                         f'Switch source to: {new_desc}?',
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if reply != QMessageBox.Yes:
                return
        self.current_source = new_idx
        self.log(f'Applied source: {new_desc}')
        # обновим статус-бар (пробуем проанализировать источник)
        self.update_source_info()

    def _source_desc(self, idx):
        names = ['File/Playlist','Camera (DirectShow)','vMix Video','NDI (requires NDI Runtime)','SRT Listener']
        return names[idx] if 0 <= idx < len(names) else 'Unknown'

    def update_source_info(self):
        fmt='—'; v='—'; fps='—'; a='—'
        ffprobe = self._ffprobe()
        if not ffprobe:
            self.src_info.setText(f'Source: {self._source_desc(self.current_source)}  |  Format: ?  |  Video: ?  |  FPS: ?  |  Audio: ?')
            return

        try:
            if self.current_source == 0:  # playlist/file
                if self.list.count() == 0:
                    self.src_info.setText('Source: File/Playlist  |  Format: —  |  Video: —  |  FPS: —  |  Audio: —')
                    return
                path = self.list.item(0).text()
                out = subprocess.check_output([ffprobe, '-v', 'error', '-select_streams', 'v:0',
                                               '-show_entries', 'stream=width,height,avg_frame_rate',
                                               '-of', 'default=noprint_wrappers=1:nokey=1', path], stderr=subprocess.STDOUT)
                parts = out.decode(errors='ignore').strip().splitlines()
                if len(parts) >= 3:
                    w,h,fr = parts[0], parts[1], parts[2]
                    v=f'{w}x{h}'; fps = fr if '/' not in fr else self._fps_str(fr)
                # audio?
                out2 = subprocess.check_output([ffprobe,'-v','error','-select_streams','a:0',
                                                '-show_entries','stream=sample_rate,channels',
                                                '-of','default=noprint_wrappers=1:nokey=1', path], stderr=subprocess.STDOUT)
                aparts = out2.decode(errors='ignore').strip().splitlines()
                if len(aparts)>=2:
                    a = f'{aparts[1]}ch @ {aparts[0]}Hz'
                fmt = os.path.splitext(path)[1].lstrip('.').upper()
            elif self.current_source == 1:  # dshow camera
                # простая попытка получить fps/size через "list_options" для конкретного устройства (может не поддерживаться)
                dev = 'video=Integrated Camera'
                fmt='DShow'
                v,fps,a = 'n/a','n/a','n/a'
            elif self.current_source == 2:  # vMix Video
                fmt='DShow(vMix)'; v,fps,a = 'n/a','n/a','n/a'
            elif self.current_source == 3:  # NDI
                fmt='NDI'; v,fps,a = 'n/a','n/a','n/a'
            else:  # SRT listener
                fmt='SRT listener'; v,fps,a='dynamic','dynamic','dynamic'
        except Exception as e:
            self.log(f'ffprobe error: {e}')

        self.src_info.setText(f'Source: {self._source_desc(self.current_source)}  |  Format: {fmt}  |  Video: {v}  |  FPS: {fps}  |  Audio: {a}')

    def _fps_str(self, fr):
        try:
            num, den = fr.split('/')
            den = float(den) if float(den)!=0 else 1.0
            return f'{float(num)/den:.2f}'
        except Exception:
            return fr

    # ---------- preview via ffplay ----------
    def preview_play(self):
        self.preview_stop()
        ply = self._ffplay()
        if not ply:
            QMessageBox.warning(self,'Preview','ffplay.exe not found in bundle.')
            return

        mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
        cmd = [ply, '-hide_banner', '-loglevel', 'error']

        if mode == 0:  # playlist/file
            if self.list.count() == 0:
                self.log('Add files to preview.')
                return
            path = self.list.item(0).text()
            cmd += [path]
        elif mode == 1:  # dshow camera
            cmd += ['-f','dshow','-i','video=Integrated Camera']
        elif mode == 2:  # vMix Video
            cmd += ['-f','dshow','-i','video=vMix Video']
        elif mode == 3:  # NDI
            self.log('NDI preview: ensure NDI Runtime installed.')
            cmd += ['-f','libndi_newtek','-i','NDI Source Name']
        else:           # SRT listener
            cmd += ['srt://0.0.0.0:9999?mode=listener']

        try:
            # запуск отдельного окна ffplay
            self.preview = subprocess.Popen(cmd)
            self.log('Preview started')
        except Exception as e:
            self.log(f'Preview error: {e}')

    def preview_stop(self):
        if self.preview and self.preview.poll() is None:
            try: self.preview.terminate()
            except: pass
        self.preview = None

    # ---------- bonding + ffmpeg encode ----------
    def _write_client_cfg(self, path):
        ports=[int(self.base_port.value())+i for i in range(int(self.paths.value()))]
        enables=[self.path_enable[i].isChecked() for i in range(int(self.paths.value()))]
        cfg={'server_ip': self.server_ip.text().strip(),'server_ports': ports,'ts_chunk': int(self.ts_chunk.value()),'enable_paths': enables}
        open(path,'w',encoding='utf-8').write(json.dumps(cfg,ensure_ascii=False,indent=2)); return cfg

    def start_all(self):
        self.stop_all()
        ff=self._ffmpeg()
        if not ff: return

        # используем ПРИМЕНЁННЫЙ источник
        mode = self.current_source if self.current_source is not None else self.src_mode.currentIndex()
        cmd=[ff,'-hide_banner','-re']

        if mode==0:
            items=[self.list.item(i).text() for i in range(self.list.count())]
            if not items: self.log('Add files to playlist.'); return
            open('playlist.txt','w',encoding='utf-8').write("\n".join([f"file '{p}'" for p in items]))
            cmd+=['-f','concat','-safe','0','-i','playlist.txt']
        elif mode==1:
            cmd+=['-f','dshow','-i','video=Integrated Camera']
        elif mode==2:
            cmd+=['-f','dshow','-i','video=vMix Video']
        elif mode==3:
            self.log('NDI selected. Ensure NDI Runtime (NDI Tools) is installed.')
            cmd+=['-f','libndi_newtek','-i','NDI Source Name']
        else:
            cmd+=['-i','srt://0.0.0.0:9999?mode=listener']

        cmd+=['-vcodec',self.vcodec.currentText(),'-profile:v',self.profile.currentText(),'-b:v',f"{self.vbit.value()}k",
              '-preset',self.preset.currentText(),'-acodec','aac','-b:a','128k','-f','mpegts','-']

        try:
            self.ff = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            self.log('ffmpeg started (bundled)')
        except Exception as e:
            self.log(f'ffmpeg error: {e}'); return

        cfg_path='bonding_client.json'; self._write_client_cfg(cfg_path)
        engine=os.path.join(os.path.dirname(sys.argv[0]),'BondingEngineClient.exe')
        if not os.path.exists(engine): self.log('BondingEngineClient.exe not found'); return
        try:
            self.eng = subprocess.Popen([engine,'--config',cfg_path], stdin=self.ff.stdout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            self.log('engine client started')
        except Exception as e:
            self.log(f'engine error: {e}')

    def stop_all(self):
        self.preview_stop()
        for p in [self.eng,self.ff]:
            if p and p.poll() is None:
                try: p.terminate()
                except: pass
        self.eng=None; self.ff=None; self.log('Stopped')

    def _pump_logs(self):
        for p in [self.ff,self.eng]:
            if p and p.stdout:
                try:
                    line=p.stdout.readline().decode(errors='ignore')
                    if line: self.logs.appendPlainText(line.rstrip())
                except Exception: pass

if __name__=='__main__':
    app=QApplication(sys.argv)
    w=ClientGUI(app); w.show()
    sys.exit(app.exec_())
